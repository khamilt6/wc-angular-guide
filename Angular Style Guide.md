# AHT.Core.UI Framework 
### Angular-based framework for Future Development
 
## 1 - Overview

Our team was tasked with the development of a new UI framework that allows existing code to continue to work (mostly) and creates an foundation for future development.

## 2 - Prerequisites

As of (TODO), the Dev branch of Workcenter has added the AHT.Core.UI folder to the WorkCenter Branch. 



**Merge DEV branch into your teams branch.**

Right click on the Dev branch, navigate to "Branching and Merging" and click "Merge..." 

![TFS Structure](TFS-Merge-Fig1.png)

Select your teams Workcenter branch as the target branch. Follow the Dialogs getting the latest version of Workcenter\Dev merged into your team branch.

![TFS Structure](TFS-Merge-Fig2.png)

After merge, you should see the following folder structure populated under your team bracnch:

![TFS Structure](AHT-Core-UI-TFS-Structure.png)


**Download and Install Visual Studio Code**

We've found that Visual Studio Code is a fast and lightweight IDE that has a number of plugins that make Angular Development easier.

Browse to [https://code.visualstudio.com/](https://code.visualstudio.com/ "https://code.visualstudio.com") to download and run the installer.

(Optional) Add these Recommended Extensions to Visual Studio Code

- [Move TS - Move TypeScript files and update relative imports](https://marketplace.visualstudio.com/items?itemName=stringham.move-ts)
- [SCSS IntelliSense](https://marketplace.visualstudio.com/items?itemName=mrmlnc.vscode-scss)
- [TSLint](https://marketplace.visualstudio.com/items?itemName=eg2.tslint)
- [Auto Import](https://marketplace.visualstudio.com/items?itemName=steoates.autoimport)

Other Useful Information

- [Keyboard Shortcuts for Visual Studio](https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf)

**Download and Install Node Package Manager**

Follow the instructions at [https://www.npmjs.com/get-npm](https://www.npmjs.com/get-npm) to install npm.

**(Recommended) Redux Dev-Tools Chrome Extension**

Download and install [Redux Dev Tools for Chrome](https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?hl=en)

**(Recommended) Angular CLI**

Angular CLI is a pretty useful tool for generated components, services, etc. 

To install it as a global npm package, run:
```cmd
npm install -g @angular/cli
```

----- 

## 3 - Getting Started
 **Basic Overview**

Layout_Template.cshtml is the file that our webpack config uses to generate the index page, Layout.cshtml, for the entry point of our application. This file contains all of the code that was previously in Layout.cshtml. Because Layout.cshtml is generated by webpack when Angular application is built, we've removed it from the project.

Webpack is the tool that we're using for bundling modules from our Angular application. It will generate the bundles, output them into AHT.UI/Scripts, and provide the reference to those bundles on Layout.cshtml. 

AHT.Core.UI is where we're keeping the Angular app in order to keep it separate from the AHT.UI MVC project. After compiling it, the bundles and assets are placed into AHT.UI, and AHT.UI needs to be run in order to view the Angular application. 


**Building AHT.Core.UI Angular Application**

Ensure that node and npm installed and up to date. 
```cmd
node -v
npm -v
```

 `package.json` in AHT.Core.UI contains the names and versions for the packages that the Angular app has depends on. For initial set up, and when new dependencies are added, you'll need to install the packages in order to build the app. Dependencies that are installed from npm are placed into the `node_modules` folder. **Don't check this folder in.** 

```cmd
npm install
```

`package.json` also contains the scripts used to build the application. After dependencies are installed, you're ready to build and start the application.
```cmd
npm run build
```

Ensure that you have a typescript linter for your chosen IDE or text editor. Most linters will find the nearest `tslint.json` file, but if not edit your linter settings to point to `tslint.json` at the root of AHT.Core.UI.


The startup projects for running the application are `AHT.Services` and `AHT.UI`.

**Committing Changes via Source Explorer in Visual Studio (NOT Visual Studio Code)**

Visual studio code doesn't automatically add newly created files to your TFS changeset, so they'll need to be manually added to Source Control via the Solution explorer. Checkins can also be done through Visual Studio.

-----

## 4 - New Concepts

**NGRX Store Overview**

The NGRX store is a state management tool for Angular applications that is inspired by Redux. 

![](Redux-diagram-fig1.png)

The purpose of the store is to be the driving force behind any UI changes. In traditional UI development, our application state is mostly driven by the DOM and updated with actions that occur in a non-centralized way. 

With the Store, we hope to centralize all UI actions and the results**** of those actions into the store. In most scenarios, we'd hope to see a mutation of the NGRX store as the cause of a UI update. **However, we are not going to be dogmatic about this concept**. If you need to animate or make simple self-contained UI changes, mutating the store is not necessary.

**File Structure**

If you think of the Store as a simple JSON object it might look something like this:

    {
	    "Context": { ... },
	    "EpisodeStay": { ... },
	    "Modal": { ... },
	    "Navigation": { ... },
	    "Person": { ... },
	    "PersonSearch": { ... },
	    "Session": { ... },
	    "User":{ ... }
    }

The store file structure should mimic the stores internal `JSON` structure:

![](store-structure.png)

Still Debating 

- *Flat vs Nested* and *Feature vs Entity Normalized*

### Implementation Details

When building a UI using the NGRX Store, you will often need to create multiple Actions, Reducers, and States.

If you need to make an API request (or need other complex updates off a single action) you'll also need to create an Effect.

To help illustrate this process, we'll go through the example of `GetUserDetails` which was one of the first things must do after loading the application.

**Store States**

It's often easiest to start with the State when thinking through a new feature/requirement. This helps you make sure you don't already have what you need somewhere else in the store.

For User Details in the JSON-concept of the store we need to look at:

	{
		"User": {
			details:{...}
		}
	}

This is defined in a file called `\Store\User\user.state.ts`:

	export interface UserState {
	    details: UserDetail;
		roleFacility: CurrentRoleFacility;
	}
	
	...


**Actions**

If we want to set the User.details object in the store, we'll need to dispatch an action.

Actions are dispatched to the Store and will result in a mutation of the state (usually).

An action should be something triggered by a user, or through a effect which processes user interactions, or from from external sources like SignalR.

Actions require a `type` but usually include a `payload`.


So in `\Store\User\user.actions.ts` we create a the following action:

	export enum UserActionTypes {
	    GETUSERDETAILS = '[User] GetUserDetails',
	    ...
	}
	
	
	export class GetUserDetails implements Action {
	    readonly type = UserActionTypes.GETUSERDETAILS;
	
	    constructor(public payload: String= '0') {}
	}

We define our `type` through an enum class so that it can be used throughout the application as necessary, but we only have to change it one spot to effect the actual value.

As you can see in the `GetUserDetails` action we have extended Action our payload is a type `String` for the user's ID/identifier

We also need to add the `GetUserDetails` action to the Union Type for type safety in the reducer.

	export type UserActions
	    = GetUserDetails
	    | GetUserDetailsSuccess
	    | GetUserDetailsError
	    | UpdateUserRoleFacility
	    | UploadUserImage
	    | UploadUserImageSuccess
	    | UploadUserImageError;

**Reducers**

Reducers are responsible for taking a action and mutating the store state based upon the payload and action type.

In `\Store\User\user.reducer.ts` we add all our reducers for the User branch.


	export function userReducer(state: UserState = { details: null, roleFacility: null}, action: UserActions | SessionActions) {
	    switch (action.type) {
	        case UserActionTypes.GETUSERDETAILS_SUCCESS:
	            return {
	                ...state,
	                details : {
	                    ...action.payload
	                },
	                roleFacility: {
	                    selectedFacilityCode: action.payload.LastSelectedFacilityCode,
	                    selectedRoleCode: Number(action.payload.LastSelectedRoleCode),
	                    SessionFacility: {
	                        Cono: action.payload.LastSelectedFacilityCode,
	                        Id: action.payload.FacilityId,
	                        Identifier: null,
	                        GMTOffSet: action.payload.GMTOffSet,
	                        ObservesDayLightSavings: action.payload.ObserveDayLightSaving
	                    }
	                }
	                
	            };
		    ...
	        default:
	            return state;
	    }
	}


If you notice, we have `UserActionTypes.GETUSERDETAILS_SUCCESS` in the switch statement, but not `UserActionTypes.GETUSERDETAILS`. This is because the `GetUserDetails` action depends on an API request, which could have at least 2 results `Status Code 200` and `Status Code 500`

**Effects**


## 5 - Components

Store is the source component UI.

**Smart Components vs. Dumb Components**

Dumb components are presentational components that should only present something in the DOM. They don't care about the state of the application, or application logic. A presentational component takes data passed from a smart component as input, and emits events back the the smart component as output.
```typescript
import { Component, OnInit, Input, Output, EventEmitter } from '@angular/core';
import { Pet } from './pet';

@Component({
  selector: 'cat-answer',
  template: `
	<p>{{cat.description}}</p>
	<div>Is this your cat?</div>
	<button (click)="answer(true)">Yes</button>
	<button (click)="answer(false)">No</button>
  `,
  styleUrls: ['./cat-answer.component.scss']
})
export class CatAnswerComponent implements OnInit {

  @Input() cat: Pet;
  @Output() onAnswer = new EventEmitter<boolean>();  

  constructor() { }

  ngOnInit() { }

  answer(answer: boolean) {
	// output the event to smart component
    this.onAnswer.emit(answer); 
  }
}
```
Smart components are the containers for our presentational components; they handle the data that is passed into presentational components, and events that are emitted from presentational components; 
```typescript
import { Component, OnInit, Input, Output, EventEmitter } from '@angular/core';
import { AppState } from './../../../store/app.state';
import { Store } from '@ngrx/store';
import { Observable } from 'rxjs/Observable';
import { combineLatest } from 'rxjs/observable/combineLatest';
import { Pet } from './pet';

@Component({
  selector: 'pet-identifer',
  template: `
	<div *ngIf="somePet$ | async as pet">
		<cat-answer [pet]="pet" (onAnswer)="answered($event)"></cat-answer>
	</div>
  `,
  styleUrls: ['./pet-identifier.component.scss']
})
export class PetComponent implements OnInit {

  somePet$: Observable<Pet>;

  constructor(private store: Store<AppState>) { }

  ngOnInit() {
	  // get some data, alter it, and send it to the dumb component
	  somePet = combineLatest(
		  this.store.pipe(select(state => state.pets)),
		  this.store.pipe(select(state => state.user.currentPet),
		  (pets: Array<Pet>, currentPet: Pet) =>  pets.find((pet) => pet.id === currentPet.id))
   }
  
  // do something with the event that comes back from the dumb component
  answered(answer: boolean) {
    this.store.dispatch(new UserFoundPet(answer)); 
  }
}
```

## 6 - Angular Services vs API Services

## 7 - Angular NgModule

Angular modules specify what components will be part of the module, other modules to import into the module, services that will be available for Angular's dependency injection, and components that will be available to other modules that import it.

Modules will be used for specific features in our application such as Faxing or Messaging. A general rule of thumb is to consolidate components, services, and utilities that are specific to features or business domains of our application into a module, although it's a good idea to place shared functionality into a shared module as well. 

The imports array will contain all other modules that a certain module depends on to function. 
```typescript
imports: [
        CommonModule,
        StoreModule.forFeature('messagingFramework', reducer),
        EffectsModule.forFeature([MessagingFrameworkEffects]),
        HttpClientModule,
        ComponentsModule,
        BrowserModule
    ],
``` 

The declarations contains components that are used in the module, and the exports array contains components that the module will expose to other modules for use.
```typescript
declarations: [MessagingFrameworkContainerComponent, TestComponent],
exports: [MessagingFrameworkContainerComponent],
// the root component of the module should be exported in order to allow an entry point for the module to be used within other modules, or the root AppModule
```
The providers array is a list of injectable services that can be injected into components or other services at runtime.
```typescript
providers: [
        MessagingFrameworkService,
        MessagingHubService,
    ]
```
All put together, the module should look something like this.
```typescript
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { StoreModule } from '@ngrx/store';
import { reducer } from './store/reducer';
import { MessagingFrameworkContainerComponent } from './messaging-framework-container/messaging-framework-container.component';
import { HttpClientModule } from '@angular/common/http';
import { MessagingFrameworkService, SignalrWindow } from './store/messaging-framework.service';
import { EffectsModule } from '@ngrx/effects';
import { MessagingFrameworkEffects } from './store/effects';
import { ComponentsModule } from '../../shared/components/components.module';
import { MessagingHubService } from './messaging-hub.service';
import { BrowserModule } from '@angular/platform-browser';
import { TestComponent } from './test/test.component';

@NgModule({
    imports: [
        CommonModule,
        StoreModule.forFeature('messagingFramework', reducer),
        EffectsModule.forFeature([MessagingFrameworkEffects]),
        HttpClientModule,
        ComponentsModule,
        BrowserModule
    ],
    declarations: [MessagingFrameworkContainerComponent, TestComponent],
    exports: [MessagingFrameworkContainerComponent],
    providers: [
        MessagingFrameworkService,
        MessagingHubService,
    ]
})
export class MessagingFrameworkModule {
}

```

Ngrx allows us to have a specific store for feature modules. If we set up the store within a module, it's lazily loaded and will wait for the module to enter scope before its state is added to the root state and its effects are registered. It will still be part of the single application state, but the code and implementation is encapsulated within the feature module that it's used. 

## 8 - Style Guide